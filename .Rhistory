xlab("") +
ylab("")
p_list[[col]] <- p
if(length(p_list)>3)
{
print(plot_grid(plotlist = p_list, nrow = 2, ncol = 2))
p_list = list()
}
}
for (col in colnames(cuml_data)[-1:-2][-13:-14]) {
p <- ggplot(cuml_data, aes(cuml_data$date, !!sym(col))) +
theme_classic() +
scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) +
scale_y_continuous(expand = c(0, 0), limits = c(0, NA)) +
labs(title = ifelse(col == "CivHarmkFreqCumulative" | col == "POW",
ifelse(col == "POW", "POWs Cumulative", "CivAttacks Cumulative"),
sprintf("Cumulative Loss of %s", col))) +
scale_x_datetime(date_labels = ifelse(col == "POW","%d %b %y" ,"%b %y"), breaks = ifelse(col == "POW",date_breaks("3 weeks") ,date_breaks("6 months"))) +
theme(text = element_text(size = 15)) +
geom_vline(xintercept = as.numeric(as.POSIXct("2022-04-09")), color = "red") + # 2022-04-09 end of initial invasion day 45
geom_vline(xintercept = as.numeric(as.POSIXct("2022-08-29")), color = "red") + # 2022-08-29 start of counteroffensive day 187
geom_vline(xintercept = as.numeric(as.POSIXct("2022-11-12")), color = "red") +  # 2022-11-12 end of counteroffensive day 262
theme(plot.title = element_text(hjust = 0.5,size=15))+
xlab("") +
ylab("")
p_list[[col]] <- p
if(length(p_list)>3)
{
print(plot_grid(plotlist = p_list, nrow = 2, ncol = 2))
p_list = list()
}
}
for (col in colnames(cuml_data)[-1:-2][-13:-14]) {
p <- ggplot(cuml_data, aes(cuml_data$date, !!sym(col))) +
geom_point(fill = "black") +
theme_classic() +
scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) +
scale_y_continuous(expand = c(0, 0), limits = c(0, NA)) +
labs(title = ifelse(col == "CivHarmkFreqCumulative" | col == "POW",
ifelse(col == "POW", "POWs Cumulative", "CivAttacks Cumulative"),
sprintf("Cumulative Loss of %s", col))) +
scale_x_datetime(date_labels = ifelse(col == "POW","%d %b %y" ,"%b %y"), breaks = ifelse(col == "POW",date_breaks("3 weeks") ,date_breaks("6 months"))) +
theme(text = element_text(size = 15)) +
geom_vline(xintercept = as.numeric(as.POSIXct("2022-04-09")), color = "red") + # 2022-04-09 end of initial invasion day 45
geom_vline(xintercept = as.numeric(as.POSIXct("2022-08-29")), color = "red") + # 2022-08-29 start of counteroffensive day 187
geom_vline(xintercept = as.numeric(as.POSIXct("2022-11-12")), color = "red") +  # 2022-11-12 end of counteroffensive day 262
theme(plot.title = element_text(hjust = 0.5,size=15))+
xlab("") +
ylab("")
p_list[[col]] <- p
if(length(p_list)>3)
{
print(plot_grid(plotlist = p_list, nrow = 2, ncol = 2))
p_list = list()
}
}
for (col in colnames(cuml_data)[-1:-2][-13:-14]) {
p <- ggplot(cuml_data, aes(cuml_data$date, !!sym(col))) +
geom_line(fill = "black") +
theme_classic() +
scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) +
scale_y_continuous(expand = c(0, 0), limits = c(0, NA)) +
labs(title = ifelse(col == "CivHarmkFreqCumulative" | col == "POW",
ifelse(col == "POW", "POWs Cumulative", "CivAttacks Cumulative"),
sprintf("Cumulative Loss of %s", col))) +
scale_x_datetime(date_labels = ifelse(col == "POW","%d %b %y" ,"%b %y"), breaks = ifelse(col == "POW",date_breaks("3 weeks") ,date_breaks("6 months"))) +
theme(text = element_text(size = 15)) +
geom_vline(xintercept = as.numeric(as.POSIXct("2022-04-09")), color = "red") + # 2022-04-09 end of initial invasion day 45
geom_vline(xintercept = as.numeric(as.POSIXct("2022-08-29")), color = "red") + # 2022-08-29 start of counteroffensive day 187
geom_vline(xintercept = as.numeric(as.POSIXct("2022-11-12")), color = "red") +  # 2022-11-12 end of counteroffensive day 262
theme(plot.title = element_text(hjust = 0.5,size=15))+
xlab("") +
ylab("")
p_list[[col]] <- p
if(length(p_list)>3)
{
print(plot_grid(plotlist = p_list, nrow = 2, ncol = 2))
p_list = list()
}
}
View(data)
View(cuml_data)
p_list <- list()
for (col in colnames(cuml_data)[-1:-2][-13:-14]) {
p <- ggplot(cuml_data, aes(cuml_data$date, !!sym(col))) +
geom_line(fill = "black") +
theme_classic() +
scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) +
scale_y_continuous(expand = c(0, 0), limits = c(0, NA)) +
labs(title = ifelse(col == "CivHarmkFreqCumulative" | col == "POW",
ifelse(col == "POW", "POWs Cumulative", "CivAttacks Cumulative"),
sprintf("Cumulative Loss of %s", col))) +
scale_x_datetime(date_labels = ifelse(col == "POW","%d %b %y" ,"%b %y"), breaks = ifelse(col == "POW",date_breaks("6 months") ,date_breaks("6 months"))) +
theme(text = element_text(size = 15)) +
geom_vline(xintercept = as.numeric(as.POSIXct("2022-04-09")), color = "red") + # 2022-04-09 end of initial invasion day 45
geom_vline(xintercept = as.numeric(as.POSIXct("2022-08-29")), color = "red") + # 2022-08-29 start of counteroffensive day 187
geom_vline(xintercept = as.numeric(as.POSIXct("2022-11-12")), color = "red") +  # 2022-11-12 end of counteroffensive day 262
theme(plot.title = element_text(hjust = 0.5,size=15))+
xlab("") +
ylab("")
p_list[[col]] <- p
if(length(p_list)>3)
{
print(plot_grid(plotlist = p_list, nrow = 2, ncol = 2))
p_list = list()
}
}
#initialize by importing/installing libraries and data
source("practicalAssignmentCustomTools.R"); source("practicalAssignmentCustomTools.R") ##bug: doesn't show the functions in my enviornment in Rstudio unless i run the command twice
initialize()
data = importData()
cuml_data = getCumulativeData()
attach(data) #important that you only attach this after you import both sets of data, many columns shared by Cumulative, and R doesn't keep data variable local to this file
######## plots##############
# Set up plot with four panels for the quantitative variables
p_list <- list()
for (col in colnames(data)[-1:-2][-13:-14]) {
p <- ggplot(data, aes(date, !!sym(col))) +
geom_col(fill = "black") +
theme_classic() +
scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) +
scale_y_continuous(expand = c(0, 0), limits = c(0, NA)) +
labs(title = ifelse(col == "CivAttackFreq" | col == "POW",
ifelse(col == "POW", "POWs per day", "CivAttack per day"),
sprintf("Loss per day of %s", col))) +
scale_x_datetime(date_labels = ifelse(col == "POW","%d %b %y" ,"%b %y"), breaks = ifelse(col == "POW",date_breaks("3 weeks") ,date_breaks("6 months"))) +
geom_smooth(method = "loess", colour = "blue",alpha=0.7, level = 0.99) +
theme(text = element_text(size = 15)) +
geom_vline(xintercept = as.numeric(as.POSIXct("2022-04-09")), color = "red") + # 2022-04-09 end of initial invasion day 45
geom_vline(xintercept = as.numeric(as.POSIXct("2022-08-29")), color = "red") + # 2022-08-29 start of counteroffensive day 187
geom_vline(xintercept = as.numeric(as.POSIXct("2022-11-12")), color = "red") +  # 2022-11-12 end of counteroffensive day 262
theme(plot.title = element_text(hjust = 0.5,size=15))+
xlab("") +
ylab("")
p_list[[col]] <- p
if(length(p_list)>3)
{
print(grid.arrange(grobs = p_list, nrow = 2, ncol = 2))
p_list = list()
}
}
#now for the cumulative data
p_list <- list()
for (col in colnames(cuml_data)[-1:-2][-13:-14]) {
p <- ggplot(cuml_data, aes(cuml_data$date, !!sym(col))) +
geom_line(fill = "black") +
theme_classic() +
scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) +
scale_y_continuous(expand = c(0, 0), limits = c(0, NA)) +
labs(title = ifelse(col == "CivHarmkFreqCumulative" | col == "POW",
ifelse(col == "POW", "POWs Cumulative", "CivAttacks Cumulative"),
sprintf("Cumulative Loss of %s", col))) +
scale_x_datetime(date_labels = ifelse(col == "POW","%d %b %y" ,"%b %y"), breaks = ifelse(col == "POW",date_breaks("6 months") ,date_breaks("6 months"))) +
theme(text = element_text(size = 15)) +
geom_vline(xintercept = as.numeric(as.POSIXct("2022-04-09")), color = "red") + # 2022-04-09 end of initial invasion day 45
geom_vline(xintercept = as.numeric(as.POSIXct("2022-08-29")), color = "red") + # 2022-08-29 start of counteroffensive day 187
geom_vline(xintercept = as.numeric(as.POSIXct("2022-11-12")), color = "red") +  # 2022-11-12 end of counteroffensive day 262
theme(plot.title = element_text(hjust = 0.5,size=15))+
xlab("") +
ylab("")
p_list[[col]] <- p
if(length(p_list)>3)
{
print(grid.arrange(grobs = p_list, nrow = 2, ncol = 2))
p_list = list()
}
}
#############################
colnames(data)[-1:-2][-13:-14]
#get rid of POW, because it has too few observations
data = names(data[,-which(names(data)=="POW")])
data
names(colnames(data)[-1:-2][-12:-13]))
names(colnames(data)[-1:-2][-12:-13])
names(names(data)[-1:-2][-12:-13])
names(names(data[-1:-2][-12:-13]))
names(names(data[-1:-2][-12:-13]))
names(data)
#initialize by importing/installing libraries and data
source("practicalAssignmentCustomTools.R"); source("practicalAssignmentCustomTools.R") ##bug: doesn't show the functions in my enviornment in Rstudio unless i run the command twice
initialize()
data = importData()
cuml_data = getCumulativeData()
attach(data) #important that you only attach this after you import both sets of data, many columns shared by Cumulative, and R doesn't keep data variable local to this file
#get rid of POW, because it has too few observations
data = data[,-which(names(data)=="POW")]
names(names(data[-1:-2][-12:-13]))
names(data)
names(names(data[-1:-2]))
names(data[-1:-2][-12:-13])
names(data[-1:-2]
names(data[-1:-2])
names(data[-1:-2])
names(data[-1:-2][-12])
names(data[-1:-2][-12:-13])
########## exploring a changepoint analyis ################
# Define the list to store the plots
plot_list <- list()
# Loop through each column of data
for (col in colnames(data)[-1:-2][-12:-13]) {
# Perform changepoint analysis
cpt <- cpt.mean(data[[col]], method = "BinSeg", minseglen = 1)
# Plot the data with the identified change points
p <- plot(cpt, main = paste0("Change point analysis of ", col))
p <- p + theme(plot.title = element_text(hjust = 0.5))
p <- p + geom_vline(xintercept = as.numeric(as.Date("2022-04-09")), color = "blue")
p <- p + geom_vline(xintercept = as.numeric(as.Date("2022-08-29")), color = "blue")
p <- p + geom_vline(xintercept = as.numeric(as.Date("2022-11-12")), color = "blue")
# Add the plot to the list
plot_list[[col]] <- p
}
data
is.na(data)
ifany(is.na(data),TRUE,FALSE)
if_any(is.na(data),TRUE,FALSE)
if_one(is.na(data),TRUE,FALSE)
ifone(is.na(data),TRUE,FALSE)
any(is.na(data),TRUE,FALSE)
View(data)
#initialize by importing/installing libraries and data
source("practicalAssignmentCustomTools.R"); source("practicalAssignmentCustomTools.R") ##bug: doesn't show the functions in my enviornment in Rstudio unless i run the command twice
initialize()
data = importData()
View(data)
View(cuml_data)
View(data)
#initialize by importing/installing libraries and data
source("practicalAssignmentCustomTools.R"); source("practicalAssignmentCustomTools.R") ##bug: doesn't show the functions in my enviornment in Rstudio unless i run the command twice
initialize()
data = importData()
cuml_data = getCumulativeData()
View(data)
attach(data) #important that you only attach this after you import both sets of data, many columns shared by Cumulative, and R doesn't keep data variable local to this file
########## exploring a changepoint analyis ################
# Define the list to store the plots
plot_list <- list()
# Loop through each column of data
for (col in colnames(data)[-1:-2][-12:-13]) {
# Perform changepoint analysis
cpt <- cpt.mean(data[[col]], method = "BinSeg", minseglen = 1)
# Plot the data with the identified change points
p <- plot(cpt, main = paste0("Change point analysis of ", col))
p <- p + theme(plot.title = element_text(hjust = 0.5))
p <- p + geom_vline(xintercept = as.numeric(as.Date("2022-04-09")), color = "blue")
p <- p + geom_vline(xintercept = as.numeric(as.Date("2022-08-29")), color = "blue")
p <- p + geom_vline(xintercept = as.numeric(as.Date("2022-11-12")), color = "blue")
# Add the plot to the list
plot_list[[col]] <- p
}
# Select 4 plots to display
selected_plots <- plot_list[1:4]
# Arrange the plots in a 2x2 grid and display them
grid.arrange(grobs = selected_plots, nrow = 2, ncol = 2)
step(lm(CivAttackFreq~.-date-day,data=data))
summary(step(lm(CivAttackFreq~.-date-day,data=data)))
View(data)
summary(step(lm(CivAttackFreq~.-date-day+lag(majorEvent),data=data)))
#initialize by importing/installing libraries and data
source("practicalAssignmentCustomTools.R"); source("practicalAssignmentCustomTools.R") ##bug: doesn't show the functions in my enviornment in Rstudio unless i run the command twice
initialize()
data = importData()
cuml_data = getCumulativeData()
attach(data) #important that you only attach this after you import both sets of data, many columns shared by Cumulative, and R doesn't keep data variable local to this file
#initialize by importing/installing libraries and data
source("practicalAssignmentCustomTools.R"); source("practicalAssignmentCustomTools.R") ##bug: doesn't show the functions in my enviornment in Rstudio unless i run the command twice
initialize()
#just quick exploration into maybe just predicitng the number of civilian attacks based on the losses for that day
glm_func <- function(data, indices) {
fit <- glm(CivAttackFreq ~ . - date - day, data = data[indices, ])
return(fit)
}
# Set up the cross-validation
cv <- cv.glm(data = data, glmfit = glm_func, K = 10)
#just quick exploration into maybe just predicitng the number of civilian attacks based on the losses for that day
glm_func <- function(data, indices) {
fit <- glm(CivAttackFreq ~ . - date - day, data = data[indices, ])
return(fit)
}
# Set up the cross-validation
cv <- cv.glm(data = data, glmfit = glm_func, K = 10)
glm_func <- function(data, indices) {
fit <- glm(CivAttackFreq ~ . - date - day, data = data[indices, ])
return(fit)
}
# Set up the cross-validation
cv <- cv.glm(data = data, glmfit = glm_func, K = 10)
glm_func <- function(data, indices) {
fit <- glm(CivAttackFreq ~ . - date - day, data = data[indices, ])
return(fit)
}
cv.glm(data = data, glmfit = glm_func, K = 10)
#just quick exploration into maybe just predicitng the number of civilian attacks based on the losses for that day
glm_func <- function(data, indices) {
fit <- glm(CivAttackFreq ~ . - date - day, data = data[indices, ], family = binomial)
return(fit)
}
cv.glm(data = data, glmfit = glm_func, K = 10)
#just quick exploration into maybe just predicitng the number of civilian attacks based on the losses for that day
glm_func <- function(data, indices) {
fit <- lm(CivAttackFreq ~ . - date - day, data = data[indices, ])
return(fit)
}
# Set up the cross-validation
cv <- cv.glm(data = data, glmfit = glm_func, K = 10)
#just quick exploration into maybe just predicitng the number of civilian attacks based on the losses for that day
full_model <- lm(formula, data = data)
full_score <- cv.glm(data, full_model, K = K)$delta[1]
#just quick exploration into maybe just predicitng the number of civilian attacks based on the losses for that day
full_model <- lm(CivAttackFreq ~ . - date - day, data = data)
full_score <- cv.glm(data, full_model, K = 10)$delta[1]
# Set up the cross-validation
cv <- cv.glm(data = data, glmfit = glm_func, K = 10)
#just quick exploration into maybe just predicitng the number of civilian attacks based on the losses for that day
full_model <- lm(CivAttackFreq ~ . - date - day, data = data)
cv <- cv.glm(data, full_model, K = 10)$delta[1]
# Get the score for each model
scores <- sapply(cv$glmfit, function(x) x$deviance)
my_stepwise <- function(formula, data, K = 10, ...) {
# Fit full model with all predictors
full_model <- lm(formula, data = data)
full_score <- cv.glm(data, full_model, K = K)$delta[1]
# Initialize empty model and selected predictors
model <- full_model
selected <- c()
available <- setdiff(names(model$coefficients), c("(Intercept)", "date", "day"))
rejected <- c()
# Add predictors one at a time
while (length(available) > 0) {
# Compute scores for all available predictors
scores <- rep(NA, length(available))
for (i in seq_along(available)) {
new_formula <- update.formula(formula, paste(".", available[i], sep = ""))
new_model <- lm(new_formula, data = data)
if (is.na(new_model$coefficients[1])) {
scores[i] <- Inf
} else {
scores[i] <- cv.glm(data, new_model, K = K)$delta[1]
}
}
# Select predictor with lowest score
best <- available[which.min(scores)]
best_score <- min(scores)
# Check if adding predictor improves score
if (best_score < full_score) {
# Add predictor to model and selected list
model <- update(model, paste(".", best, sep = ""))
selected <- c(selected, best)
# Remove predictor from available list
available <- setdiff(available, best)
} else {
# Reject remaining predictors
rejected <- c(rejected, available)
break
}
}
# Fit final model with selected predictors
final_formula <- update.formula(formula, paste(". ~ ", paste(selected, collapse = " + "), sep = ""))
final_model <- lm(final_formula, data = data)
final_score <- cv.glm(data, final_model, K = K)$delta[1]
# Return selected model and score
return(list(model = final_model, score = final_score))
}
my_stepwise <- function(formula, data, K = 10, ...) {
# Fit full model with all predictors
full_model <- lm(formula, data = data)
full_score <- cv.glm(data, full_model, K = K)$delta[1]
# Initialize empty model and selected predictors
model <- full_model
selected <- c()
available <- setdiff(names(model$coefficients), c("(Intercept)", "date", "day"))
rejected <- c()
# Add predictors one at a time
while (length(available) > 0) {
# Compute scores for all available predictors
scores <- rep(NA, length(available))
for (i in seq_along(available)) {
new_formula <- update.formula(formula, paste(".", available[i], sep = ""))
new_model <- lm(new_formula, data = data)
if (is.na(new_model$coefficients[1])) {
scores[i] <- Inf
} else {
scores[i] <- cv.glm(data, new_model, K = K)$delta[1]
}
}
# Select predictor with lowest score
best <- available[which.min(scores)]
best_score <- min(scores)
# Check if adding predictor improves score
if (best_score < full_score) {
# Add predictor to model and selected list
model <- update(model, paste(".", best, sep = ""))
selected <- c(selected, best)
# Remove predictor from available list
available <- setdiff(available, best)
} else {
# Reject remaining predictors
rejected <- c(rejected, available)
break
}
}
# Fit final model with selected predictors
final_formula <- update.formula(formula, paste(". ~ ", paste(selected, collapse = " + "), sep = ""))
final_model <- lm(final_formula, data = data)
final_score <- cv.glm(data, final_model, K = K)$delta[1]
# Return selected model and score
return(list(model = final_model, score = final_score))
}
# Perform stepwise selection with cross-validation score
result <- my_stepwise(CivAttackFreq ~ . - date - day, data = data)
#initialize by importing/installing libraries and data
source("practicalAssignmentCustomTools.R"); source("practicalAssignmentCustomTools.R") ##bug: doesn't show the functions in my enviornment in Rstudio unless i run the command twice
initialize()
#initialize by importing/installing libraries and data
source("practicalAssignmentCustomTools.R"); source("practicalAssignmentCustomTools.R") ##bug: doesn't show the functions in my enviornment in Rstudio unless i run the command twice
initialize()
#initialize by importing/installing libraries and data
source("practicalAssignmentCustomTools.R"); source("practicalAssignmentCustomTools.R") ##bug: doesn't show the functions in my enviornment in Rstudio unless i run the command twice
initialize()
#just quick exploration into maybe just predicitng the number of civilian attacks based on the losses for that day
# Perform cross-validation to select the best lambda value
cv.fit <- cv.glmnet(x, y, alpha = 1)
best.lambda <- cv.fit$lambda.min
# Fit LASSO model with the best lambda value
lasso.fit <- glmnet(x, y, alpha = 1, lambda = best.lambda)
coef.lasso <- coef(lasso.fit)
# Extract the selected variables
selected.vars <- names(coef.lasso)[-1][coef.lasso[-1] != 0]
data[,-"date"]
data[,"date"]
data[,-"date"]
data[,-c("date")]
data[,-which(names(data)=="date")]
names(data[,-which(names(data)=="date")][,-which(names(data)=="day"])
names(data[,-which(names(data)=="date")])
names(data[,-which(names(data)=="date")][,-which(names(data)=="day"])
names((data[,-which(names(data)=="date")])[,-which(names(data)=="day"])
names(data[,-which(names(data)=="date")])
names((data[,-which(names(data)=="date")][,-which(names(data)=="day"])
names(data[,-which(names(data)=="date")][,-which(names(data)=="day"])
data[,-which(names(data)=="date")][,-which(names(data)=="day"]
(data[,-which(names(data)=="date")])[,-which(names(data)=="day"]
data[,-which(names(data)=="date")][,-which(names(data)=="day"]
X = data[,-which(names(data)=="date")]
Y = X[,-which(names(data)=="day"]
Y = X[,-which(names(data)=="day"]
names(data[,-which(names(data)=="date")][,-which(names(data)=="day")])
names(data[,-which(names(data)=="day")][,-which(names(data)=="day")])
names(data[,-which(names(data)=="day")][,-which(names(data)=="date")])
names(data[,-which(names(data)=="day")][,-which(names(data)=="date")])
names(data[,-which(names(data)=="date")][,-which(names(data)=="day")])
x=data[,-which(names(data)=="date")]
y=x[,-which(names(data)=="day")])
y=x[,-which(names(data)=="day")]
names(y)
x=data[,-which(names(data)=="date")]
y=x[,-which(names(x)=="day")]
names(y)
data[, !names(data) %in% c("date", "day")]
names(data[, !names(data) %in% c("date", "day")])
#just quick exploration into maybe just predicitng the number of civilian attacks based on the losses for that day
# Perform cross-validation to select the best lambda value
cv.fit <- cv.glmnet(data["CivAttackFreq"], as.matrix(data[, !names(data) %in% c("date", "day","CivAttackFreq")], alpha = 1)
dfasdf
#just quick exploration into maybe just predicitng the number of civilian attacks based on the losses for that day
# Perform cross-validation to select the best lambda value
cv.fit <- cv.glmnet(data["CivAttackFreq"], as.matrix(data[, !names(data) %in% c("date", "day","CivAttackFreq")]), alpha = 1)
#just quick exploration into maybe just predicitng the number of civilian attacks based on the losses for that day
# Perform cross-validation to select the best lambda value
cv.fit <- cv.glmnet(as.matrix(data[, !names(data) %in% c("date", "day","CivAttackFreq")]),data["CivAttackFreq"], alpha = 1)
#just quick exploration into maybe just predicitng the number of civilian attacks based on the losses for that day
# Perform cross-validation to select the best lambda value
cv.fit <- cv.glmnet(as.matrix(data[, !names(data) %in% c("date", "day","CivAttackFreq")]),data[["CivAttackFreq"]], alpha = 1)
best.lambda <- cv.fit$lambda.min
# Fit LASSO model with the best lambda value
lasso.fit <- glmnet(x, y, alpha = 1, lambda = best.lambda)
# Fit LASSO model with the best lambda value
lasso.fit <- glmnet(as.matrix(data[, !names(data) %in% c("date", "day","CivAttackFreq")]),data[["CivAttackFreq"]], alpha = 1, lambda = best.lambda)
coef.lasso <- coef(lasso.fit)
# Extract the selected variables
selected.vars <- names(coef.lasso)[-1][coef.lasso[-1] != 0]
# Fit the final model with the selected variables
final.model <- lm(CivAttackFreq ~ ., data = data[, c("CivAttackFreq", selected.vars)])
summary(final.model)
#just quick exploration into maybe just predicitng the number of civilian attacks based on the losses for that day
# Perform cross-validation to select the best lambda value
cv.fit <- cv.glmnet(as.matrix(data[, !names(data) %in% c("date", "day","CivAttackFreq")]),data[["CivAttackFreq"]], alpha = 1)
best.lambda <- cv.fit$lambda.min
# Fit LASSO model with the best lambda value
lasso.fit <- glmnet(as.matrix(data[, !names(data) %in% c("date", "day","CivAttackFreq")]),data[["CivAttackFreq"]], alpha = 1, lambda = best.lambda)
coef.lasso <- coef(lasso.fit)
# Extract the selected variables
selected.vars <- names(coef.lasso)[-1][coef.lasso[-1] != 0]
# Fit the final model with the selected variables
final.model <- lm(CivAttackFreq ~ ., data = data[, c("CivAttackFreq", selected.vars)])
selected.vars
data[["CivAttackFreq"]]
#just quick exploration into maybe just predicitng the number of civilian attacks based on the losses for that day
# Perform cross-validation to select the best lambda value
cv.fit <- cv.glmnet(as.matrix(data[, !names(data) %in% c("date", "day","CivAttackFreq")]),data[["CivAttackFreq"]], alpha = 1)
best.lambda <- cv.fit$lambda.min
# Fit LASSO model with the best lambda value
lasso.fit <- glmnet(as.matrix(data[, !names(data) %in% c("date", "day","CivAttackFreq")]),data[["CivAttackFreq"]], alpha = 1, lambda = best.lambda)
summary(lasso.fit)
summary( coef(lasso.fit))
#just quick exploration into maybe just predicitng the number of civilian attacks based on the losses for that day
# Perform cross-validation to select the best lambda value
cv.fit <- cv.glmnet(as.matrix(data[, !names(data) %in% c("date", "day","CivAttackFreq")]),data[["CivAttackFreq"]], alpha = 1)
best.lambda <- cv.fit$lambda.min
# Fit LASSO model with the best lambda value
lasso.fit <- glmnet(as.matrix(data[, !names(data) %in% c("date", "day","CivAttackFreq")]),data[["CivAttackFreq"]], alpha = 1, lambda = best.lambda)
coef.lasso <- coef(lasso.fit, s = best.lambda)
coef(lasso.fit, s = best.lambda)
