threshold_sd_range,
threshold_days_range,
moving_average_days_range,
majorLossThreshold_range,
minNumberOfCivAttacks,
data)
} else {
resultsBIC <- read.csv("resultsBIC.csv")
}
best_result_BIC <- resultsBIC[which.min(as.numeric(resultsBIC[,'bic'])),]
finalModelBIC = get_model_or_metric(best_result_BIC$threshold_sd,
best_result_BIC$threshold_days,
best_result_BIC$moving_average_days,
best_result_BIC$majorLossThreshold,
minNumberOfCivAttacks,
data)
source("~/Practical Assignment/Practical Assignment 1.R")
View(best_result_AIC)
View(best_result_BIC)
View(best_result_BIC)
View(best_result_BIC)
View(best_result_AIC)
View(best_result_BIC)
View(best_result_AIC)
View(best_result_BIC)
View(best_result_AIC)
View(best_result_BIC)
View(best_result_AIC)
View(best_result_AIC)
View(best_result_AIC)
View(best_result_BIC)
View(best_result_AIC)
View(best_result_BIC)
View(best_result_AIC)
View(best_result_BIC)
View(best_result_AIC)
View(best_result_BIC)
View(best_result_AIC)
View(best_result_BIC)
View(best_result_AIC)
View(best_result_BIC)
View(best_result_AIC)
View(best_result_BIC)
View(best_result_AIC)
View(best_result_BIC)
View(best_result_AIC)
View(best_result_BIC)
View(best_result_AIC)
View(best_result_BIC)
View(best_result_AIC)
#initialize by importing/installing libraries and data
source("practicalAssignmentCustomTools.R"); source("practicalAssignmentCustomTools.R") ##bug: doesn't show the functions in my enviornment in Rstudio unless i run the command twice
initialize()
data = importData()
cuml_data = getCumulativeData()
attach(data,warn.conflicts = FALSE) #important that you only attach this after you import both sets of data, many columns shared by Cumulative, and R doesn't keep data variable local to this file
threshold_sd_range <- seq(1, 3, by = 0.3)
threshold_days_range <- seq(5, 10, by = 1)
moving_average_days_range <- seq(10,35, by = 5)
majorLossThreshold_range <- seq(1,3, by = 1)
total_step_calls = length(threshold_sd_range)*length(threshold_days_range)*length(moving_average_days_range)*length(majorLossThreshold_range)
minNumberOfCivAttacks = 10  #if you don't set this higher than 0 (good min is at least 30), the automation will make the response variable completely false, making the intercept a perfect predictor.
runBIC = TRUE  #flag that determines if the long process of performing step regressions on all combinations of hyper parameters. If set to FALSE, loads results from backup.
runAIC = TRUE  #flag that determines if the long process of performing step regressions on all combinations of hyper parameters. If set to FALSE, loads results from backup.
#get the best model based on aic and hyperparameter range
if(runBIC)
{
resultsBIC = get_all_stepwiseReduced_models("bic",
total_step_calls,
threshold_sd_range,
threshold_days_range,
moving_average_days_range,
majorLossThreshold_range,
minNumberOfCivAttacks,
data)
} else {
resultsBIC <- read.csv("resultsBIC.csv")
}
source("~/Practical Assignment/Practical Assignment 1.R")
#initialize by importing/installing libraries and data
source("practicalAssignmentCustomTools.R"); source("practicalAssignmentCustomTools.R") ##bug: doesn't show the functions in my enviornment in Rstudio unless i run the command twice
initialize()
data = importData()
cuml_data = getCumulativeData()
attach(data,warn.conflicts = FALSE) #important that you only attach this after you import both sets of data, many columns shared by Cumulative, and R doesn't keep data variable local to this file
#
#from the plots above, i saw i could not identify shocks from just using an average change. The variation changed over time. The mean from which the variation should be observed from also changed over time.
#I identified that major shifts in the offensives could be used to split up the data. However, this wasn't a perfect choice, it didn't line up perfectly with the offensive dates, and many other variables unaccounted for could be affecting variablity and mean over time. Furthermore, gradual changes in mean and variation won't be captured by a changepoint analysis.
#A moving average and sd was more effective at identifying shocks in this case.
#Hyperparameters for searching for best regressions
threshold_sd_range <- seq(1, 3, by = 0.3)
threshold_days_range <- seq(5, 10, by = 1)
moving_average_days_range <- seq(10,35, by = 5)
majorLossThreshold_range <- seq(1,3, by = 1)
total_step_calls = length(threshold_sd_range)*length(threshold_days_range)*length(moving_average_days_range)*length(majorLossThreshold_range)
minNumberOfCivAttacks = 10  #if you don't set this higher than 0 (good min is at least 30), the automation will make the response variable completely false, making the intercept a perfect predictor.
runBIC = TRUE  #flag that determines if the long process of performing step regressions on all combinations of hyper parameters. If set to FALSE, loads results from backup.
runAIC = TRUE  #flag that determines if the long process of performing step regressions on all combinations of hyper parameters. If set to FALSE, loads results from backup.
#get the best model based on aic and hyperparameter range
if(runBIC)
{
resultsBIC = get_all_stepwiseReduced_models("bic",
total_step_calls,
threshold_sd_range,
threshold_days_range,
moving_average_days_range,
majorLossThreshold_range,
minNumberOfCivAttacks,
data)
} else {
resultsBIC <- read.csv("resultsBIC.csv")
}
best_result_BIC <- resultsBIC[which.min(as.numeric(resultsBIC[,'bic'])),]
finalModelBIC = get_model_or_metric(best_result_BIC$threshold_sd,
best_result_BIC$threshold_days,
best_result_BIC$moving_average_days,
best_result_BIC$majorLossThreshold,
minNumberOfCivAttacks,
data)
#get the best model based on aic and hyperparameter range
if(runAIC)
{
resultsAIC = get_all_stepwiseReduced_models("aic",
total_step_calls,
threshold_sd_range,
threshold_days_range,
moving_average_days_range,
majorLossThreshold_range,
minNumberOfCivAttacks,
data)
} else {
resultsAIC <- read.csv("resultsAIC.csv")
}
best_result_AIC <- resultsAIC[which.min(as.numeric(resultsAIC[,'aic'])),]
finalModelAIC = get_model_or_metric(best_result_AIC$threshold_sd,
best_result_AIC$threshold_days,
best_result_AIC$moving_average_days,
best_result_AIC$majorLossThreshold,
minNumberOfCivAttacks,
data)
cat("Final Model BIC based:",
"\n\tStd devs indication of spike: ",best_result_BIC$threshold_sd,
"\n\tLag days to calculate the average and std dev for spikes: ",best_result_BIC$moving_average_days,
"\n\tDays looked backwards to check if a major spike occurred: ",best_result_BIC$threshold_days,
"\n\tNumber of simulataneous spikes accross all explanatory variables to determine the major event variable: ",best_result_BIC$threshold_days,
"\n\tMinimum number of spikes necessary in Civilian Attack Frequency for an acceptable model: ",minNumberOfCivAttacks)
print(summary(finalModelBIC))
cat("Final Model AIC based:",
"\n\tStd devs indication of spike: ",best_result_AIC$threshold_sd,
"\n\tLag days to calculate the average and std dev for spikes: ",best_result_AIC$moving_average_days,
"\n\tDays looked backwards to check if a major spike occurred: ",best_result_AIC$threshold_days,
"\n\tNumber of simulataneous spikes accross all explanatory variables to determine the major event variable: ",best_result_AIC$threshold_days,
"\n\tMinimum number of spikes necessary in Civilian Attack Frequency for an acceptable model: ",minNumberOfCivAttacks)
print(summary(finalModelAIC))
didBigSpikeOccurOverLastWeek
#check if big loss occurred over threshold of days
didBigSpikeOccurOverLastWeek = get_didBigSpikeOccurOverLastWeek(threshold_sd, threshold_days, moving_average_days,majorLossThreshold,data)
#create Big loss variables
threshold_sd = 2 #number of standard deviations above moving average change that indicates a big loss for the day
moving_average_days =  30 #number of days to include in the moving average for the standard deviation
threshold_days = 7 #number of days until the
majorLossThreshold = 3
#check if big loss occurred over threshold of days
didBigSpikeOccurOverLastWeek = get_didBigSpikeOccurOverLastWeek(threshold_sd, threshold_days, moving_average_days,majorLossThreshold,data)
didBigSpikeOccurOverLastWeek
didBigSpikeOccurOverLastWeek$CivAttackFreq
summary(didBigSpikeOccurOverLastWeek$CivAttackFreq)
View(didBigSpikeOccurOverLastWeek)
View(didBigSpikeOccurOverLastWeek)
weights <- ifelse(didBigSpikeOccurOverLastWeek$CivAttackFreq == TRUE, 1/sum(didBigSpikeOccurOverLastWeek$CivAttackFreq == TRUE), 1/sum(didBigSpikeOccurOverLastWeek$CivAttackFreq == FALSE))
weights
summary(weights)
#initialize by importing/installing libraries and data
source("practicalAssignmentCustomTools.R"); source("practicalAssignmentCustomTools.R") ##bug: doesn't show the functions in my enviornment in Rstudio unless i run the command twice
initialize()
data = importData()
cuml_data = getCumulativeData()
attach(data,warn.conflicts = FALSE) #important that you only attach this after you import both sets of data, many columns shared by Cumulative, and R doesn't keep data variable local to this file
########## exploring regressions ################
#from the plots above, i saw i could not identify shocks from just using an average change. The variation changed over time. The mean from which the variation should be observed from also changed over time.
#I identified that major shifts in the offensives could be used to split up the data. However, this wasn't a perfect choice, it didn't line up perfectly with the offensive dates, and many other variables unaccounted for could be affecting variablity and mean over time. Furthermore, gradual changes in mean and variation won't be captured by a changepoint analysis.
#A moving average and sd was more effective at identifying shocks in this case.
#Hyperparameters for searching for best regressions
threshold_sd_range <- seq(1, 3, by = 0.3)
threshold_days_range <- seq(5, 10, by = 1)
moving_average_days_range <- seq(10,35, by = 5)
majorLossThreshold_range <- seq(1,3, by = 1)
total_step_calls = length(threshold_sd_range)*length(threshold_days_range)*length(moving_average_days_range)*length(majorLossThreshold_range)
minNumberOfCivAttacks = 15  #if you don't set this higher than 0 (good min is at least 30), the automation will make the response variable completely false, making the intercept a perfect predictor.
runBIC = TRUE  #flag that determines if the long process of performing step regressions on all combinations of hyper parameters. If set to FALSE, loads results from backup.
runAIC = TRUE  #flag that determines if the long process of performing step regressions on all combinations of hyper parameters. If set to FALSE, loads results from backup.
#get the best model based on aic and hyperparameter range
if(runBIC)
{
resultsBIC = get_all_stepwiseReduced_models("bic",
total_step_calls,
threshold_sd_range,
threshold_days_range,
moving_average_days_range,
majorLossThreshold_range,
minNumberOfCivAttacks,
data)
} else {
resultsBIC <- read.csv("resultsBIC.csv")
}
best_result_BIC <- resultsBIC[which.min(as.numeric(resultsBIC[,'bic'])),]
finalModelBIC = get_model_or_metric(best_result_BIC$threshold_sd,
best_result_BIC$threshold_days,
best_result_BIC$moving_average_days,
best_result_BIC$majorLossThreshold,
minNumberOfCivAttacks,
data)
#get the best model based on aic and hyperparameter range
if(runAIC)
{
resultsAIC = get_all_stepwiseReduced_models("aic",
total_step_calls,
threshold_sd_range,
threshold_days_range,
moving_average_days_range,
majorLossThreshold_range,
minNumberOfCivAttacks,
data)
} else {
resultsAIC <- read.csv("resultsAIC.csv")
}
best_result_AIC <- resultsAIC[which.min(as.numeric(resultsAIC[,'aic'])),]
finalModelAIC = get_model_or_metric(best_result_AIC$threshold_sd,
best_result_AIC$threshold_days,
best_result_AIC$moving_average_days,
best_result_AIC$majorLossThreshold,
minNumberOfCivAttacks,
data)
warnings()
#initialize by importing/installing libraries and data
source("practicalAssignmentCustomTools.R"); source("practicalAssignmentCustomTools.R") ##bug: doesn't show the functions in my enviornment in Rstudio unless i run the command twice
initialize()
data = importData()
cuml_data = getCumulativeData()
attach(data,warn.conflicts = FALSE) #important that you only attach this after you import both sets of data, many columns shared by Cumulative, and R doesn't keep data variable local to this file
threshold_sd_range <- seq(1, 3, by = 0.3)
threshold_days_range <- seq(5, 10, by = 1)
moving_average_days_range <- seq(10,35, by = 5)
majorLossThreshold_range <- seq(1,3, by = 1)
total_step_calls = length(threshold_sd_range)*length(threshold_days_range)*length(moving_average_days_range)*length(majorLossThreshold_range)
minNumberOfCivAttacks = 15  #if you don't set this higher than 0 (good min is at least 30), the automation will make the response variable completely false, making the intercept a perfect predictor.
runBIC = TRUE  #flag that determines if the long process of performing step regressions on all combinations of hyper parameters. If set to FALSE, loads results from backup.
runAIC = TRUE  #flag that determines if the long process of performing step regressions on all combinations of hyper parameters. If set to FALSE, loads results from backup.
#get the best model based on aic and hyperparameter range
if(runBIC)
{
resultsBIC = get_all_stepwiseReduced_models("bic",
total_step_calls,
threshold_sd_range,
threshold_days_range,
moving_average_days_range,
majorLossThreshold_range,
minNumberOfCivAttacks,
data)
} else {
resultsBIC <- read.csv("resultsBIC.csv")
}
best_result_BIC <- resultsBIC[which.min(as.numeric(resultsBIC[,'bic'])),]
finalModelBIC = get_model_or_metric(best_result_BIC$threshold_sd,
best_result_BIC$threshold_days,
best_result_BIC$moving_average_days,
best_result_BIC$majorLossThreshold,
minNumberOfCivAttacks,
data)
#get the best model based on aic and hyperparameter range
if(runAIC)
{
resultsAIC = get_all_stepwiseReduced_models("aic",
total_step_calls,
threshold_sd_range,
threshold_days_range,
moving_average_days_range,
majorLossThreshold_range,
minNumberOfCivAttacks,
data)
} else {
resultsAIC <- read.csv("resultsAIC.csv")
}
best_result_AIC <- resultsAIC[which.min(as.numeric(resultsAIC[,'aic'])),]
finalModelAIC = get_model_or_metric(best_result_AIC$threshold_sd,
best_result_AIC$threshold_days,
best_result_AIC$moving_average_days,
best_result_AIC$majorLossThreshold,
minNumberOfCivAttacks,
data)
warnnings()
warnings()
#check if big loss occurred over threshold of days
didBigSpikeOccurOverLastWeek = get_didBigSpikeOccurOverLastWeek(threshold_sd, threshold_days, moving_average_days,majorLossThreshold,data)
View(didBigSpikeOccurOverLastWeek)
View(didBigSpikeOccurOverLastWeek)
#initialize by importing/installing libraries and data
source("practicalAssignmentCustomTools.R"); source("practicalAssignmentCustomTools.R") ##bug: doesn't show the functions in my enviornment in Rstudio unless i run the command twice
initialize()
data = importData()
cuml_data = getCumulativeData()
########## exploring regressions ################
#from the plots above, i saw i could not identify shocks from just using an average change. The variation changed over time. The mean from which the variation should be observed from also changed over time.
#I identified that major shifts in the offensives could be used to split up the data. However, this wasn't a perfect choice, it didn't line up perfectly with the offensive dates, and many other variables unaccounted for could be affecting variablity and mean over time. Furthermore, gradual changes in mean and variation won't be captured by a changepoint analysis.
#A moving average and sd was more effective at identifying shocks in this case.
#Hyperparameters for searching for best regressions
threshold_sd_range <- seq(1, 3, by = 0.3)
threshold_days_range <- seq(5, 10, by = 1)
moving_average_days_range <- seq(10,35, by = 5)
majorLossThreshold_range <- seq(1,3, by = 1)
total_step_calls = length(threshold_sd_range)*length(threshold_days_range)*length(moving_average_days_range)*length(majorLossThreshold_range)
minNumberOfCivAttacks = 15  #if you don't set this higher than 0 (good min is at least 30), the automation will make the response variable completely false, making the intercept a perfect predictor.
runBIC = TRUE  #flag that determines if the long process of performing step regressions on all combinations of hyper parameters. If set to FALSE, loads results from backup.
runAIC = TRUE  #flag that determines if the long process of performing step regressions on all combinations of hyper parameters. If set to FALSE, loads results from backup.
#get the best model based on aic and hyperparameter range
if(runBIC)
{
resultsBIC = get_all_stepwiseReduced_models("bic",
total_step_calls,
threshold_sd_range,
threshold_days_range,
moving_average_days_range,
majorLossThreshold_range,
minNumberOfCivAttacks,
data)
} else {
resultsBIC <- read.csv("resultsBIC.csv")
}
best_result_BIC <- resultsBIC[which.min(as.numeric(resultsBIC[,'bic'])),]
finalModelBIC = get_model_or_metric(best_result_BIC$threshold_sd,
best_result_BIC$threshold_days,
best_result_BIC$moving_average_days,
best_result_BIC$majorLossThreshold,
minNumberOfCivAttacks,
data)
#get the best model based on aic and hyperparameter range
if(runAIC)
{
resultsAIC = get_all_stepwiseReduced_models("aic",
total_step_calls,
threshold_sd_range,
threshold_days_range,
moving_average_days_range,
majorLossThreshold_range,
minNumberOfCivAttacks,
data)
} else {
resultsAIC <- read.csv("resultsAIC.csv")
}
best_result_AIC <- resultsAIC[which.min(as.numeric(resultsAIC[,'aic'])),]
finalModelAIC = get_model_or_metric(best_result_AIC$threshold_sd,
best_result_AIC$threshold_days,
best_result_AIC$moving_average_days,
best_result_AIC$majorLossThreshold,
minNumberOfCivAttacks,
data)
#check if big loss occurred over threshold of days
didBigSpikeOccurOverLastWeek = get_didBigSpikeOccurOverLastWeek(threshold_sd, threshold_days, moving_average_days,majorLossThreshold,data)
View(didBigSpikeOccurOverLastWeek)
as.integer(didBigSpikeOccurOverLastWeek$MajorLossCount > majorLossThreshold)
source("practicalAssignmentCustomTools.R"); source("practicalAssignmentCustomTools.R") ##bug: doesn't show the functions in my enviornment in Rstudio unless i run the command twice
initialize()
data = importData()
cuml_data = getCumulativeData()
attach(data,warn.conflicts = FALSE) #important that you only attach this after you import both sets of data, many columns shared by Cumulative, and R doesn't keep data variable local to this file
########## exploring regressions ################
#from the plots above, i saw i could not identify shocks from just using an average change. The variation changed over time. The mean from which the variation should be observed from also changed over time.
#I identified that major shifts in the offensives could be used to split up the data. However, this wasn't a perfect choice, it didn't line up perfectly with the offensive dates, and many other variables unaccounted for could be affecting variablity and mean over time. Furthermore, gradual changes in mean and variation won't be captured by a changepoint analysis.
#A moving average and sd was more effective at identifying shocks in this case.
#Hyperparameters for searching for best regressions
threshold_sd_range <- seq(1, 3, by = 0.3)
threshold_days_range <- seq(5, 10, by = 1)
moving_average_days_range <- seq(10,35, by = 5)
majorLossThreshold_range <- seq(1,3, by = 1)
total_step_calls = length(threshold_sd_range)*length(threshold_days_range)*length(moving_average_days_range)*length(majorLossThreshold_range)
minNumberOfCivAttacks = 15  #if you don't set this higher than 0 (good min is at least 30), the automation will make the response variable completely false, making the intercept a perfect predictor.
runBIC = TRUE  #flag that determines if the long process of performing step regressions on all combinations of hyper parameters. If set to FALSE, loads results from backup.
runAIC = TRUE  #flag that determines if the long process of performing step regressions on all combinations of hyper parameters. If set to FALSE, loads results from backup.
#get the best model based on aic and hyperparameter range
if(runBIC)
{
resultsBIC = get_all_stepwiseReduced_models("bic",
total_step_calls,
threshold_sd_range,
threshold_days_range,
moving_average_days_range,
majorLossThreshold_range,
minNumberOfCivAttacks,
data)
} else {
resultsBIC <- read.csv("resultsBIC.csv")
}
best_result_BIC <- resultsBIC[which.min(as.numeric(resultsBIC[,'bic'])),]
finalModelBIC = get_model_or_metric(best_result_BIC$threshold_sd,
best_result_BIC$threshold_days,
best_result_BIC$moving_average_days,
best_result_BIC$majorLossThreshold,
minNumberOfCivAttacks,
data)
#check if big loss occurred over threshold of days
didBigSpikeOccurOverLastWeek = get_didBigSpikeOccurOverLastWeek(threshold_sd, threshold_days, moving_average_days,majorLossThreshold,data)
View(didBigSpikeOccurOverLastWeek)
warnings()
#initialize by importing/installing libraries and data
source("practicalAssignmentCustomTools.R"); source("practicalAssignmentCustomTools.R") ##bug: doesn't show the functions in my enviornment in Rstudio unless i run the command twice
initialize()
data = importData()
cuml_data = getCumulativeData()
attach(data,warn.conflicts = FALSE) #important that you only attach this after you import both sets of data, many columns shared by Cumulative, and R doesn't keep data variable local to this file
threshold_sd_range <- seq(1, 3, by = 0.3)
threshold_days_range <- seq(5, 10, by = 1)
moving_average_days_range <- seq(10,35, by = 5)
majorLossThreshold_range <- seq(1,3, by = 1)
total_step_calls = length(threshold_sd_range)*length(threshold_days_range)*length(moving_average_days_range)*length(majorLossThreshold_range)
minNumberOfCivAttacks = 15  #if you don't set this higher than 0 (good min is at least 30), the automation will make the response variable completely false, making the intercept a perfect predictor.
runBIC = TRUE  #flag that determines if the long process of performing step regressions on all combinations of hyper parameters. If set to FALSE, loads results from backup.
runAIC = TRUE  #flag that determines if the long process of performing step regressions on all combinations of hyper parameters. If set to FALSE, loads results from backup.
#get the best model based on aic and hyperparameter range
if(runBIC)
{
resultsBIC = get_all_stepwiseReduced_models("bic",
total_step_calls,
threshold_sd_range,
threshold_days_range,
moving_average_days_range,
majorLossThreshold_range,
minNumberOfCivAttacks,
data)
} else {
resultsBIC <- read.csv("resultsBIC.csv")
}
best_result_BIC <- resultsBIC[which.min(as.numeric(resultsBIC[,'bic'])),]
finalModelBIC = get_model_or_metric(best_result_BIC$threshold_sd,
best_result_BIC$threshold_days,
best_result_BIC$moving_average_days,
best_result_BIC$majorLossThreshold,
minNumberOfCivAttacks,
data)
#initialize by importing/installing libraries and data
source("practicalAssignmentCustomTools.R"); source("practicalAssignmentCustomTools.R") ##bug: doesn't show the functions in my enviornment in Rstudio unless i run the command twice
initialize()
data = importData()
cuml_data = getCumulativeData()
attach(data,warn.conflicts = FALSE) #important that you only attach this after you import both sets of data, many columns shared by Cumulative, and R doesn't keep data variable local to this file
threshold_sd_range <- seq(1, 3, by = 0.3)
threshold_days_range <- seq(5, 10, by = 1)
moving_average_days_range <- seq(10,35, by = 5)
majorLossThreshold_range <- seq(1,3, by = 1)
total_step_calls = length(threshold_sd_range)*length(threshold_days_range)*length(moving_average_days_range)*length(majorLossThreshold_range)
minNumberOfCivAttacks = 15  #if you don't set this higher than 0 (good min is at least 30), the automation will make the response variable completely false, making the intercept a perfect predictor.
runBIC = TRUE  #flag that determines if the long process of performing step regressions on all combinations of hyper parameters. If set to FALSE, loads results from backup.
runAIC = TRUE  #flag that determines if the long process of performing step regressions on all combinations of hyper parameters. If set to FALSE, loads results from backup.
#get the best model based on aic and hyperparameter range
if(runBIC)
{
resultsBIC = get_all_stepwiseReduced_models("bic",
total_step_calls,
threshold_sd_range,
threshold_days_range,
moving_average_days_range,
majorLossThreshold_range,
minNumberOfCivAttacks,
data)
} else {
resultsBIC <- read.csv("resultsBIC.csv")
}
best_result_BIC <- resultsBIC[which.min(as.numeric(resultsBIC[,'bic'])),]
finalModelBIC = get_model_or_metric(best_result_BIC$threshold_sd,
best_result_BIC$threshold_days,
best_result_BIC$moving_average_days,
best_result_BIC$majorLossThreshold,
minNumberOfCivAttacks,
data)
print(summary(finalModelBIC))
View(best_result_BIC)
source("practicalAssignmentCustomTools.R"); source("practicalAssignmentCustomTools.R") ##bug: doesn't show the functions in my enviornment in Rstudio unless i run the command twice
initialize()
data = importData()
cuml_data = getCumulativeData()
attach(data,warn.conflicts = FALSE) #important that you only attach this after you import both sets of data, many columns shared by Cumulative, and R doesn't keep data variable local to this file
if(runBIC)
{
resultsBIC = get_all_stepwiseReduced_models("bic",
total_step_calls,
threshold_sd_range,
threshold_days_range,
moving_average_days_range,
majorLossThreshold_range,
minNumberOfCivAttacks,
data)
} else {
resultsBIC <- read.csv("resultsBIC.csv")
}
best_result_BIC <- resultsBIC[which.min(as.numeric(resultsBIC[,'bic'])),]
finalModelBIC = get_model_or_metric(best_result_BIC$threshold_sd,
best_result_BIC$threshold_days,
best_result_BIC$moving_average_days,
best_result_BIC$majorLossThreshold,
minNumberOfCivAttacks,
data)
print(summary(finalModelBIC))
model1 = glm(CivAttackFreq~majorEvent,data=didBigSpikeOccurOverLastWeek,family="binomial")
model2 = glm(CivAttackFreq~MajorLossCount,data=didBigSpikeOccurOverLastWeek,family="binomial")
model3 = glm(CivAttackFreq~MajorLoss,data=didBigSpikeOccurOverLastWeek,family="binomial")
model4 = glm(CivAttackFreq~majorEvent+MajorLossCount,data=didBigSpikeOccurOverLastWeek,family="binomial")
model5 = glm(CivAttackFreq~majorEvent+MajorLoss,data=didBigSpikeOccurOverLastWeek,family="binomial")
print(summary(model1))
print(exp(confint(model1)))
print(summary(model2))
print(summary(model3))
print(summary(model4))
print(summary(model5))
